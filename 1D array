# Partition Equal Subset Sum

# Problem Description:
# Given an array nums, determine if it can be partitioned into two subsets 
# such that the sums of the elements in both subsets are equal.

# Example:
# Input: nums = [1, 5, 11, 5]
# Output: True
# Explanation: The array can be partitioned as [1, 5, 5] and [11].

# Constraints:
# - The length of nums is between 1 and 200.
# - Each element of nums is between 1 and 100.


# Approach:
# Dynamic Programming:
# - This problem reduces to checking if a subset of nums can sum to `target = totalSum // 2`.

# Key Observations:
# 1. If the total sum of nums is odd, partitioning is impossible.
# 2. If the total sum is even, check if a subset exists that sums to target.

# Dynamic Programming Array Definition:
# - dp[t] = True means a subset of nums can sum to t.

# Steps:
# 1. Compute the total sum of nums. If totalSum % 2 != 0, return False.
# 2. Initialize a DP array of size `target + 1` with dp[0] = True.
# 3. Iterate through each number in nums, and for each number, iterate backward from target to num.
# 4. Update the DP array:
#    dp[t] = dp[t] or dp[t - num]
# 5. Return dp[target], which indicates whether the target sum is achievable.

# Code Implementation:
class Solution:
    def canPartition(self, nums):
        # Compute the total sum of nums
        totalSum = sum(nums)

        # If the total sum is odd, partitioning is impossible
        if totalSum % 2 != 0:
            return False

        # Compute the target sum
        target = totalSum // 2

        # Initialize a DP array of size `target + 1`
        dp = [False] * (target + 1)
        dp[0] = True  # Base case: a sum of 0 is always achievable

        # Process each number in nums
        for num in nums:
            # Update DP array backward to avoid reusing numbers
            for t in range(target, num - 1, -1):
                dp[t] = dp[t] or dp[t - num]

        # Return whether the target sum is achievable
        return dp[target]


# Complexity Analysis:
# Time Complexity:
# - O(n * target): Iterates through each number in nums and updates the DP array of size target.

# Space Complexity:
# - O(target): Uses a 1D DP array of size target + 1.

# Example Walkthrough:
# Input:
# nums = [1, 5, 11, 5]

# Execution:
# 1. totalSum = 22, target = 11
# 2. Initialize dp = [True, False, False, ..., False] (size target + 1)
# 3. Process nums:
#    - For num = 1: Update achievable sums in dp.
#    - For num = 5: Update achievable sums in dp.
#    - For num = 11: Update achievable sums in dp.
# 4. Output: True

# Related Problems:
# - Subset Sum Problem
# - 0/1 Knapsack Problem
# - Coin Change Problem (with constraints)
